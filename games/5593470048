-- MADE BY .antilua.
-- OPTIMIZED VERSION
VERSION="1.7.5"
assert(isfolder and makefolder, "Unable to create folder")
local _xpcall, _pcall, _task, _math = xpcall, pcall, task, math
if not isfolder("MIDI") then
	makefolder("MIDI")
	writefile("./MIDI/Summer.mid", game:HttpGetAsync("https://github.com/Ukrubojvo/api/raw/refs/heads/main/Summer.mid"))
end

if game.PlaceId ~= 5593470048 then return end -- Visual Pianos GameID
if not shared.AntiLuaLoading then
	shared.AntiLuaLoading = true
else
	return "Already Loaded"
end

local run = function(func)
	_xpcall(func, function(err)
		shared.AntiLuaLoading = false
		warn(err)
	end)
end

local WindUI
run(function()
	local ok, res = _pcall(function()
		return require("./src/Init")
	end)
	if ok and res then
		WindUI = res
	else
		WindUI = loadstring(game:HttpGetAsync("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
	end
end)

local function missing(t, f, fallback)
	if type(f) == t then
		return f
	end
	return fallback
end

local cloneref = missing("function", cloneref, function(...)
	return ...
end)
local Services = setmetatable({}, {
	__index = function(self, name)
		self[name] = cloneref(game:GetService(name))
		return self[name]
	end
})

local oldgame = game
local game = workspace.Parent
local run_service = Services.RunService
local vim = Services.VirtualInputManager
local uis = Services.UserInputService
local players = Services.Players
local player = players.LocalPlayer

local ProtectGui = protectgui or (syn and syn.protect_gui) or function()
end
local GUIParent = gethui and gethui() or game.CoreGui

local key_map = {
    [21] = {keycode = Enum.KeyCode.One, ctrl = true},
    [22] = {keycode = Enum.KeyCode.Two, ctrl = true},
    [23] = {keycode = Enum.KeyCode.Three, ctrl = true},
    [24] = {keycode = Enum.KeyCode.Four, ctrl = true},
    [25] = {keycode = Enum.KeyCode.Five, ctrl = true},
    [26] = {keycode = Enum.KeyCode.Six, ctrl = true},
    [27] = {keycode = Enum.KeyCode.Seven, ctrl = true},
    [28] = {keycode = Enum.KeyCode.Eight, ctrl = true},
    [29] = {keycode = Enum.KeyCode.Nine, ctrl = true},
    [30] = {keycode = Enum.KeyCode.Zero, ctrl = true},
    [31] = {keycode = Enum.KeyCode.Q, ctrl = true},
    [32] = {keycode = Enum.KeyCode.W, ctrl = true},
    [33] = {keycode = Enum.KeyCode.E, ctrl = true},
    [34] = {keycode = Enum.KeyCode.R, ctrl = true},
    [35] = {keycode = Enum.KeyCode.T, ctrl = true},
    [36] = {keycode = Enum.KeyCode.One, shift = false}, [37] = {keycode = Enum.KeyCode.One, shift = true},
    [38] = {keycode = Enum.KeyCode.Two, shift = false}, [39] = {keycode = Enum.KeyCode.Two, shift = true},
    [40] = {keycode = Enum.KeyCode.Three, shift = false}, [41] = {keycode = Enum.KeyCode.Four, shift = false},
    [42] = {keycode = Enum.KeyCode.Four, shift = true}, [43] = {keycode = Enum.KeyCode.Five, shift = false},
    [44] = {keycode = Enum.KeyCode.Five, shift = true}, [45] = {keycode = Enum.KeyCode.Six, shift = false},
    [46] = {keycode = Enum.KeyCode.Six, shift = true}, [47] = {keycode = Enum.KeyCode.Seven, shift = false},
    [48] = {keycode = Enum.KeyCode.Eight, shift = false}, [49] = {keycode = Enum.KeyCode.Eight, shift = true},
    [50] = {keycode = Enum.KeyCode.Nine, shift = false}, [51] = {keycode = Enum.KeyCode.Nine, shift = true},
    [52] = {keycode = Enum.KeyCode.Zero, shift = false}, [53] = {keycode = Enum.KeyCode.Q, shift = false},
    [54] = {keycode = Enum.KeyCode.Q, shift = true}, [55] = {keycode = Enum.KeyCode.W, shift = false},
    [56] = {keycode = Enum.KeyCode.W, shift = true}, [57] = {keycode = Enum.KeyCode.E, shift = false},
    [58] = {keycode = Enum.KeyCode.E, shift = true}, [59] = {keycode = Enum.KeyCode.R, shift = false},
    [60] = {keycode = Enum.KeyCode.T, shift = false}, [61] = {keycode = Enum.KeyCode.T, shift = true},
    [62] = {keycode = Enum.KeyCode.Y, shift = false}, [63] = {keycode = Enum.KeyCode.Y, shift = true},
    [64] = {keycode = Enum.KeyCode.U, shift = false}, [65] = {keycode = Enum.KeyCode.I, shift = false},
    [66] = {keycode = Enum.KeyCode.I, shift = true}, [67] = {keycode = Enum.KeyCode.O, shift = false},
    [68] = {keycode = Enum.KeyCode.O, shift = true}, [69] = {keycode = Enum.KeyCode.P, shift = false},
    [70] = {keycode = Enum.KeyCode.P, shift = true}, [71] = {keycode = Enum.KeyCode.A, shift = false},
    [72] = {keycode = Enum.KeyCode.S, shift = false}, [73] = {keycode = Enum.KeyCode.S, shift = true},
    [74] = {keycode = Enum.KeyCode.D, shift = false}, [75] = {keycode = Enum.KeyCode.D, shift = true},
    [76] = {keycode = Enum.KeyCode.F, shift = false}, [77] = {keycode = Enum.KeyCode.G, shift = false},
    [78] = {keycode = Enum.KeyCode.G, shift = true}, [79] = {keycode = Enum.KeyCode.H, shift = false},
    [80] = {keycode = Enum.KeyCode.H, shift = true}, [81] = {keycode = Enum.KeyCode.J, shift = false},
    [82] = {keycode = Enum.KeyCode.J, shift = true}, [83] = {keycode = Enum.KeyCode.K, shift = false},
    [84] = {keycode = Enum.KeyCode.L, shift = false}, [85] = {keycode = Enum.KeyCode.L, shift = true},
    [86] = {keycode = Enum.KeyCode.Z, shift = false}, [87] = {keycode = Enum.KeyCode.Z, shift = true},
    [88] = {keycode = Enum.KeyCode.X, shift = false}, [89] = {keycode = Enum.KeyCode.C, shift = false},
    [90] = {keycode = Enum.KeyCode.C, shift = true}, [91] = {keycode = Enum.KeyCode.V, shift = false},
    [92] = {keycode = Enum.KeyCode.V, shift = true}, [93] = {keycode = Enum.KeyCode.B, shift = false},
    [94] = {keycode = Enum.KeyCode.B, shift = true}, [95] = {keycode = Enum.KeyCode.N, shift = false},
    [96] = {keycode = Enum.KeyCode.M, shift = false}, [97] = {keycode = Enum.KeyCode.M, shift = true},
    [98] = {keycode = Enum.KeyCode.U, ctrl = true}, [99] = {keycode = Enum.KeyCode.I, ctrl = true},
    [100] = {keycode = Enum.KeyCode.O, ctrl = true}, [101] = {keycode = Enum.KeyCode.P, ctrl = true},
    [102] = {keycode = Enum.KeyCode.A, ctrl = true}, [103] = {keycode = Enum.KeyCode.S, ctrl = true},
    [104] = {keycode = Enum.KeyCode.D, ctrl = true}, [105] = {keycode = Enum.KeyCode.F, ctrl = true},
    [106] = {keycode = Enum.KeyCode.G, ctrl = true}, [107] = {keycode = Enum.KeyCode.H, ctrl = true},
    [108] = {keycode = Enum.KeyCode.J, ctrl = true}
}

local PianoController
local events = {}
local tempo_events = {}
local sustain = true
local key88_enabled = true
local auto_sustain_enabled = true
local auto_velocity_enabled = true
local no_note_off_enabled = false
local random_note_enabled = false
local deblack_enabled = false
local deblack_level = 65
local deblack_strict = true
local FastNoteOff = false
local FastNoteOffDelay = 0.02
local shift = false
local ctrl = false
local active_notes = {}
local loop_enabled = false
local start_time = 0
local next_event_index = 1
local paused = false
local pause_position = 0
local total_duration = 0
local midi_files = {}
local playback_speed = 1.0
local midi_loaded = false
local is_loading = false
local played_slider_ref

local folder_name = "MIDI"
if not isfolder(folder_name) then
	makefolder(folder_name)
end

local ignore_played_slider_callback = false
local ignore_speed_slider_callback = false

local function read_var_int(data, offset)
	local value = 0
	local bytes_read = 0
	while true do
		local byte = string.byte(data, offset + bytes_read)
		if not byte then
			break
		end
		bytes_read = bytes_read + 1
		value = bit32.bor(bit32.lshift(value, 7), bit32.band(byte, 127))
		if bit32.band(byte, 128) == 0 then
			break
		end
	end
	return value, bytes_read
end

local function calculate_realtime_position(ticks, ticks_per_beat, tempo_changes)
	local current_tick = 0
	local current_time_ms = 0
	local current_tempo = 500000
	for i = 1, #tempo_changes do
		local tempo_event = tempo_changes[i]
		if tempo_event.tick <= ticks then
			local tick_diff = tempo_event.tick - current_tick
			current_time_ms = current_time_ms + (tick_diff * current_tempo / 1000) / ticks_per_beat
			current_tick = tempo_event.tick
			current_tempo = tempo_event.tempo
		else
			break
		end
	end
	local remaining_ticks = ticks - current_tick
	current_time_ms = current_time_ms + (remaining_ticks * current_tempo / 1000) / ticks_per_beat
	return current_time_ms / 1000
end

local function apply_deblack(parsed_events)
	if not deblack_enabled then
		return parsed_events
	end
	local note_on_times = {}
	local last_note_off = {}
	local keep_indexes = {}
	local n = #parsed_events
	for i = 1, n do
		local note = parsed_events[i]
		if not note.abs_time or type(note.abs_time) ~= "number" then
			keep_indexes[i] = true
		elseif note.type == "control" then
			keep_indexes[i] = true
		elseif not note.channel or not note.note then
			keep_indexes[i] = true
		else
			local key = tostring(note.channel) .. ":" .. tostring(note.note)
			if note.vel and note.vel > 0 then
				local should_ignore = false
				if deblack_strict then
					local prev_off = last_note_off[key]
					if prev_off and prev_off.t and prev_off.v and type(prev_off.t) == "number" then
						local dt = note.abs_time - prev_off.t
						local vel_diff = _math.abs(note.vel - prev_off.v)
						if dt < 0.035 and vel_diff < 7 then
							should_ignore = true
						end
					end
				end
				if not should_ignore then
					note_on_times[key] = {
						t = note.abs_time,
						idx = i,
						v = note.vel
					}
				end
			else
				local on_data = note_on_times[key]
				if on_data and on_data.t and on_data.v and type(on_data.t) == "number" then
					local dt = (note.abs_time - on_data.t) * 1000
					local vel = on_data.v
					last_note_off[key] = {
						t = note.abs_time,
						v = vel
					}
					note_on_times[key] = nil
					if not (vel <= (deblack_level) and dt < 20) then
						keep_indexes[on_data.idx] = true
						keep_indexes[i] = true
					end
				else
					keep_indexes[i] = true
				end
			end
		end
	end
	local filtered_events = {}
	local filtered_count = 0
	for i = 1, n do
		if keep_indexes[i] then
			filtered_count = filtered_count + 1
			filtered_events[filtered_count] = parsed_events[i]
		end
	end
	return filtered_events
end

local function parse_midi_improved(data, loading_label)
	local buffer = data
	local offset = 1
	local track_end_offset = 0
	local is_header_parsed = false
	local ticks_per_beat = 0
	local last_status_byte = nil
	local track_time = 0
	local note_on_stack = {}
	local parsed_events = {}
	local tempo_changes = {
		{
			tick = 0,
			tempo = 500000
		}
	}
	local event_count = 0
	local last_yield = os.clock()
	while true do
		if os.clock() - last_yield > 0.033 then
			_task.wait()
			last_yield = os.clock()
			if loading_label and loading_label.Parent then
				loading_label.Text = string.format("‚è≥ Parsing... %d events", event_count)
			end
		end
		if not is_header_parsed then
			if #buffer < 14 then
				break
			end
			if string.sub(buffer, 1, 4) ~= 'MThd' then
				break
			end
			ticks_per_beat = string.unpack(">H", buffer, 13)
			offset = 15
			is_header_parsed = true
		end
		if offset >= track_end_offset then
			if #buffer - offset + 1 < 8 then
				break
			end
			if string.sub(buffer, offset, offset + 3) ~= 'MTrk' then
				break
			end
			offset = offset + 4
			local track_length = string.unpack(">I4", buffer, offset)
			offset = offset + 4
			track_end_offset = offset + track_length - 1
			last_status_byte = nil
			track_time = 0
			note_on_stack = {}
		end
		if offset > track_end_offset then
			break
		end
		local delta, delta_bytes = read_var_int(buffer, offset)
		offset = offset + delta_bytes
		track_time = track_time + delta
		local status
		local status_byte = string.byte(buffer, offset)
		if not status_byte then
			break
		end
		if bit32.band(status_byte, 128) ~= 0 then
			last_status_byte = status_byte
			status = status_byte
			offset = offset + 1
		else
			if last_status_byte == nil then
				break
			end
			status = last_status_byte
		end
		local command = bit32.band(status, 240)
		local channel = bit32.band(status, 15)
		if command == 144 or command == 128 then
			local note_number = string.byte(buffer, offset)
			local velocity = string.byte(buffer, offset + 1)
			if not note_number or not velocity then
				break
			end
			offset = offset + 2
			local is_on = command == 144 and velocity > 0
			local key = tostring(note_number) .. ":" .. tostring(channel)
			if is_on then
				if note_on_stack[key] then
					local prev = note_on_stack[key]
					local length_ticks = track_time - prev.on_tick
					if length_ticks > 0 then
						local on_time = calculate_realtime_position(prev.on_tick, ticks_per_beat, tempo_changes)
						local off_time = calculate_realtime_position(track_time, ticks_per_beat, tempo_changes)
						event_count = event_count + 2
						parsed_events[event_count - 1] = {
							type = 'on',
							note = prev.note_name,
							vel = prev.velocity,
							channel = prev.channel,
							abs_time = on_time,
							tick = prev.on_tick
						}
						parsed_events[event_count] = {
							type = 'off',
							note = prev.note_name,
							channel = prev.channel,
							abs_time = off_time,
							tick = track_time
						}
					end
					note_on_stack[key] = nil
				end
				note_on_stack[key] = {
					on_tick = track_time,
					velocity = velocity,
					note_name = note_number,
					channel = channel
				}
			else
				local prev = note_on_stack[key]
				if prev then
					local length_ticks = track_time - prev.on_tick
					if length_ticks > 0 then
						local on_time = calculate_realtime_position(prev.on_tick, ticks_per_beat, tempo_changes)
						local off_time = calculate_realtime_position(track_time, ticks_per_beat, tempo_changes)
						event_count = event_count + 2
						parsed_events[event_count - 1] = {
							type = 'on',
							note = prev.note_name,
							vel = prev.velocity,
							channel = prev.channel,
							abs_time = on_time,
							tick = prev.on_tick
						}
						parsed_events[event_count] = {
							type = 'off',
							note = prev.note_name,
							channel = prev.channel,
							abs_time = off_time,
							tick = track_time
						}
					end
					note_on_stack[key] = nil
				end
			end
		elseif command == 176 then
			local controller_type = string.byte(buffer, offset)
			local value = string.byte(buffer, offset + 1)
			if not controller_type or not value then
				break
			end
			offset = offset + 2
			if controller_type == 64 then
				local control_time = calculate_realtime_position(track_time, ticks_per_beat, tempo_changes)
				event_count = event_count + 1
				parsed_events[event_count] = {
					type = 'control',
					vel = value,
					abs_time = control_time,
					tick = track_time
				}
			end
		elseif status == 255 then
			local meta_type = string.byte(buffer, offset)
			if not meta_type then
				break
			end
			offset = offset + 1
			local length, length_bytes = read_var_int(buffer, offset)
			offset = offset + length_bytes
			if meta_type == 81 and length == 3 then
				local b1, b2, b3 = string.byte(buffer, offset, offset + 2)
				if b1 and b2 and b3 then
					local micro_per_beat = b1 * 65536 + b2 * 256 + b3
					table.insert(tempo_changes, {
						tick = track_time,
						tempo = micro_per_beat
					})
				end
			end
			offset = offset + length
		else
			local data_len = (command == 192 or command == 208) and 1 or 2
			offset = offset + data_len
		end
		if offset > track_end_offset then
			offset = track_end_offset + 1
		end
	end
	for key, prev in pairs(note_on_stack) do
		local on_time = calculate_realtime_position(prev.on_tick, ticks_per_beat, tempo_changes)
		event_count = event_count + 1
		parsed_events[event_count] = {
			type = 'on',
			note = prev.note_name,
			vel = prev.velocity,
			channel = prev.channel,
			abs_time = on_time,
			tick = prev.on_tick
		}
	end
	if loading_label and loading_label.Parent then
		loading_label.Text = "‚è≥ Sorting events..."
	end
	_task.wait()
	table.sort(parsed_events, function(a, b)
		return a.abs_time < b.abs_time
	end)
	if loading_label and loading_label.Parent then
		loading_label.Text = "‚è≥ Applying deblack..."
	end
	_task.wait()
	parsed_events = apply_deblack(parsed_events)
	return parsed_events, tempo_changes
end

local function release_all_keys()
	if PianoController then
		for _, k in pairs(active_notes) do
			PianoController:ReleaseClientKey(k.keycode.Value)
		end
		if ctrl then
			PianoController:ReleaseClientKey(Enum.KeyCode.LeftControl.Value)
			ctrl = false
		end
		if shift then
			PianoController:ReleaseClientKey(Enum.KeyCode.LeftShift.Value)
			shift = false
		end
		if sustain then
			PianoController:ReleaseClientKey(Enum.KeyCode.Space.Value)
			sustain = false
		end
	end
	active_notes = {}
end

local function get_current_playback_position()
	if paused then
		return pause_position
	else
		return (os.clock() - start_time) * playback_speed
	end
end

local function play_realtime_events()
	if paused then
		return
	end
	local elapsed = get_current_playback_position()
	while next_event_index <= #events do
		local ev = events[next_event_index]
		local event_time = ev.abs_time
		
		if ev.type == "off" and FastNoteOff then
			event_time = ev.abs_time - (FastNoteOffDelay or 0)
			if event_time < 0 then
				event_time = 0
			end
		end
		
		if ev.type == "on" and random_note_enabled then
			local random_offset = _math.random(0, 5) * 0.01
			event_time = ev.abs_time - random_offset
			if event_time < 0 then
				event_time = 0
			end
		end
		
		if event_time <= elapsed then
			if ev.type == "on" then
				local k = key_map[ev.note]
				if k then
					if not key88_enabled and k.ctrl then
						next_event_index = next_event_index + 1
						continue
					end
                    if k.ctrl ~= nil then
                        if k.ctrl and not ctrl then
                            ctrl = true
                        elseif not k.ctrl and ctrl then
                            ctrl = false
                        end
                    end
                    
                    if k.shift ~= nil then
                        if k.shift and not shift then
                            shift = true
                        elseif not k.shift and shift then
                            shift = false
                        end
                    end
                    
                    local velocity = ev.vel
                    _pcall(function()
                        if PianoController.SetVelocity and auto_velocity_enabled then
                            PianoController:SetVelocity(velocity)
                        end
                    end)
                    
                    local noteIndex = ev.note
					if noteIndex then
						local keycode_value = k.keycode
						if typeof(keycode_value) == "EnumItem" then
							keycode_value = keycode_value.Value
						end
						
						PianoController:PressClientKey(
							keycode_value,
							noteIndex - 20,
							nil,
							nil,
							nil,
							nil,
							nil
						)
						
						active_notes[ev.note] = k
						
						if no_note_off_enabled then
							local k = active_notes[ev.note]
							if k then
								local release_keycode = k.keycode
								if typeof(release_keycode) == "EnumItem" then
									release_keycode = release_keycode.Value
								end
								PianoController:ReleaseClientKey(release_keycode)
								active_notes[ev.note] = nil
							end
						end
					end
				end
			elseif ev.type == "off" then
				if not no_note_off_enabled then
					local k = active_notes[ev.note]
					if k then
						local keycode_value = k.keycode
						if typeof(keycode_value) == "EnumItem" then
							keycode_value = keycode_value.Value
						end
						PianoController:ReleaseClientKey(keycode_value)
						active_notes[ev.note] = nil
					end
				end
			elseif ev.type == "control" then
				local s = ev.vel >= 64
				if auto_sustain_enabled then
					if s ~= sustain then
						_pcall(function()
							if PianoController then
								PianoController:ToggleSustain(s)
							end
						end)
						sustain = s
					end
				else
					if not sustain then
						sustain = true
						_pcall(function()
							if PianoController then
								PianoController:ToggleSustain(true)
							end
						end)
					end
				end
			end
			next_event_index = next_event_index + 1
		else
			break
		end
	end
	if next_event_index > #events then
		if loop_enabled then
			next_event_index = 1
			start_time = os.clock()
			pause_position = 0
			release_all_keys()
		else
			paused = true
			start_time = 0
			next_event_index = 1
			pause_time = 0
			pause_position = 0
			release_all_keys()
		end
	end
end

local function start_playback(parsed_events, tempo_changes)
	if not PianoController or not PianoController.Piano then
		for i, v in pairs(getgc(true)) do
			if typeof(v) == 'table' and rawget(v, 'Active') and rawget(v, 'Piano') then
				PianoController = v

                PianoController._modules.DefaultSettings = require(Knit.Modules.DefaultSettings)
                PianoController._settings = PianoController._modules.DefaultSettings

                PianoController._VELOCITY_CURVES = PianoController._settings.DEFAULT_VELOCITY_CURVES
			end
		end
	end
	events = parsed_events
	tempo_events = tempo_changes or {}
	total_duration = events[#events] and events[#events].abs_time or 0
	start_time = os.clock()
	next_event_index = 1
	pause_position = 0
	if not auto_sustain_enabled then
        sustain = true
        _pcall(function()
            if PianoController then
                PianoController:ToggleSustain(true)
            end
        end)
    end
	release_all_keys()
	paused = false
	midi_loaded = true
end

local function pause_playback()
	if not paused then
		paused = true
		pause_time = os.clock()
		pause_position = (os.clock() - start_time) * playback_speed
		release_all_keys()
	end
end

local function resume_playback()
	if paused then
		start_time = os.clock() - (pause_position / playback_speed)
		paused = false
	end
end

local function stop_playback()
	paused = true
	start_time = 0
	next_event_index = 1
	pause_time = 0
	pause_position = 0
	release_all_keys()
end

local function seek_to_position(ratio)
	local target_time = total_duration * ratio
	pause_position = target_time
	next_event_index = 1
	for i = 1, #events do
		if events[i].abs_time > target_time then
			next_event_index = i
			break
		end
	end
	if not paused then
		start_time = os.clock() - (target_time / playback_speed)
	end
	release_all_keys()
end

local function list_midi_files()
	midi_files = {}
	local ok, files = _pcall(listfiles, "./MIDI")
	if ok and files then
		for _, f in ipairs(files) do
			if f:match("%.mid$") then
				table.insert(midi_files, f:match("[^/\\]+$"))
			end
		end
	end
end

local function load_midi_from_data(data, ui_setter)
	if is_loading then
		return
	end
	is_loading = true
	ui_setter("‚è≥ Parsing MIDI...")
	_task.spawn(function()
		events = {}
		tempo_events = {}
		local ok, parsed, tempochg = _pcall(function()
			return parse_midi_improved(data, {
				Parent = true,
				Text = ""
			})
		end)
		if not ok or not parsed then
			ui_setter("‚ùå Invalid MIDI or parse error")
			is_loading = false
			return
		end
		parsed = apply_deblack(parsed)
		events = parsed
		tempo_events = tempochg or {}
		total_duration = events[#events] and events[#events].abs_time or 0
		next_event_index = 1
		pause_position = 0
		paused = true
		midi_loaded = true
		is_loading = false
		if played_slider_ref and total_duration > 0 then
			played_slider_ref:SetMin(0)
			played_slider_ref:SetMax(total_duration)
		end
		ui_setter("‚úÖ Loaded " .. #events .. " events (" .. string.format("%.3f", total_duration) .. "s)")
	end)
end

run(function()
	local Anonymous = false
	local Window
	Window = WindUI:CreateWindow({
		Title = "MIDI Player | Visual Pianos",
		Author = "Made by .antilua. and .dayun.",
		Size = UDim2.fromOffset(600, 260),
		SideBarWidth = 150,
		Folder = "AntiLua",
		NewElements = true,
		HideSearchBar = true,
		User = {
			Enabled = true,
			Anonymous = false,
			Callback = function()
				Anonymous = not Anonymous
				Window:SetAnonymous(Anonymous)
			end,
		},
	})
	Window:Tag({
        Title = "v" .. VERSION,
        Icon = "github",
        Color = Color3.fromHex("#1c1c1c")
    })
	Window:OnDestroy(function()
		shared.AntiLuaLoading = false
		stop_playback()
		release_all_keys()
		events = {}
		tempo_events = {}
		midi_loaded = false
		is_loading = false
	end)
	local MainTab = Window:Tab({
		Title = "Main",
		Icon = "house",
	})
	local SettingsTab = Window:Tab({
		Title = "Settings",
		Icon = "settings",
	})
	local status_label = MainTab:Paragraph({
		Title = "Status",
		Desc = "Ready"
	})
	list_midi_files()
	local file_vals = {}
	for _, f in ipairs(midi_files) do
		table.insert(file_vals, f)
	end
	local selected_file = nil
	local url_input_value = ""
	local url_input = MainTab:Input({
		Title = "URL or Filename",
		Placeholder = "https:// or filename.mid",
		Callback = function(val)
			url_input_value = val
		end
	})
	MainTab:Button({
		Title = "Download",
		Callback = function()
			local txt = url_input_value or ""
			if not string.match(txt, "^https?://") then
				status_label:SetDesc("‚ùå Invalid URL")
				return
			end

			local clean = string.match(txt, "([^%?]+)")
			if not clean then
				status_label:SetDesc("‚ùå Invalid URL")
				return
			end

			local filename = string.match(clean, ".+/([^/]+)$")
			if not filename then
				status_label:SetDesc("‚ùå Cannot extract filename")
				return
			end

			local lower = string.lower(filename)
			if not (string.sub(lower, -4) == ".mid" or string.sub(lower, -5) == ".midi") then
				status_label:SetDesc("‚ùå Not a MIDI file")
				return
			end

			filename = string.gsub(filename, "_", " ")
			if not isfolder("./MIDI") then
				makefolder("./MIDI")
			end

			local savePath = "./MIDI/" .. filename
			status_label:SetDesc("‚è≥ Downloading...")

			_task.spawn(function()
				local ok, data = _pcall(function()
					return game:HttpGet(txt)
				end)

				if not ok or not data then
					status_label:SetDesc("‚ùå Download failed")
					return
				end

				if string.sub(data, 1, 4) ~= "MThd" then
					status_label:SetDesc("‚ùå Invalid MIDI header")
					WindUI:Notify({
						Title = "MidiPlayer",
						Content = "File is not a valid MIDI (MThd missing)",
						Duration = 4,
						Icon = "bird",
					})
					return
				end

				writefile(savePath, data)
				status_label:SetDesc("‚úÖ Saved: " .. filename)

				WindUI:Notify({
					Title = "MidiPlayer",
					Content = "Saved as " .. filename,
					Duration = 4,
					Icon = "bird",
				})
			end)
		end
	})

	local file_dropdown = MainTab:Dropdown({
		Title = "MIDI Files",
		Desc = "Choose from ./MIDI",
		Values = file_vals,
		Value = midi_files[1] or nil,
		Callback = function(option)
			selected_file = option
			url_input:Set(option)
			status_label:SetDesc("Selected: " .. option)
		end
	})
	MainTab:Button({
		Title = "Load",
		Callback = function()
			if is_loading then
				status_label:SetDesc("Already loading...")
				WindUI:Notify({
					Title = "MidiPlayer",
					Content = "Already loading...",
					Duration = 3,
					Icon = "bird",
				})
				return
			end
			local load_source = nil
			local txt = url_input_value or ""
			if txt ~= "" then
				load_source = "url"
			elseif selected_file then
				txt = selected_file
				load_source = "file"
			else
				status_label:SetDesc("‚ùå No file selected or URL entered")
				WindUI:Notify({
					Title = "MidiPlayer",
					Content = "No file selected or URL entered",
					Duration = 3,
					Icon = "bird",
				})
				return
			end
			if load_source == "url" and string.match(txt, "^https?://") then
				status_label:SetDesc("‚è≥ Downloading...")
				_task.spawn(function()
					local ok, body = _pcall(function()
						return game:HttpGet(txt)
					end)
					if ok and body then
						load_midi_from_data(body, function(txt)
							status_label:SetDesc(txt)
							WindUI:Notify({
								Title = "MidiPlayer",
								Content = txt,
								Duration = 10,
								Icon = "bird",
							})
						end)
					else
						status_label:SetDesc("‚ùå Download failed")
						is_loading = false
					end
				end)
			else
				local file_path = "./MIDI/" .. txt
				if not isfile(file_path) then
					status_label:SetDesc("‚ùå File not found: " .. txt)
					return
				end
				local ok, data = _pcall(readfile, file_path)
				if ok and data then
					status_label:SetDesc("‚è≥ Loading file...")
					load_midi_from_data(data, function(txt)
						status_label:SetDesc(txt)
						WindUI:Notify({
							Title = "MidiPlayer",
							Content = txt,
							Duration = 10,
							Icon = "bird",
						})
					end)
				else
					status_label:SetDesc("‚ùå Failed to read file: " .. txt)
				end
			end
		end
	})
	MainTab:Button({
		Title = "Refresh File List",
		Callback = function()
			list_midi_files()
			local vals = {}
			for _, f in ipairs(midi_files) do
				table.insert(vals, f)
			end
			file_dropdown:Refresh(vals)
			status_label:SetDesc("üîÑ Found " .. #midi_files .. " files")
		end
	})
	MainTab:Button({
		Title = "Play",
		Callback = function()
			if not midi_loaded then
				status_label:SetDesc("‚ùå No MIDI loaded")
				return
			end
			if paused and pause_position > 0 then
				resume_playback()
				status_label:SetDesc("‚ñ∂Ô∏è Resumed")
			elseif paused and pause_position == 0 then
				start_playback(events, tempo_events)
				status_label:SetDesc("‚ñ∂Ô∏è Playing")
			else
				status_label:SetDesc("‚ÑπÔ∏è Already playing")
			end
		end
	})
	MainTab:Button({
		Title = "Pause",
		Callback = function()
			if paused then
				resume_playback()
				status_label:SetDesc("‚ñ∂Ô∏è Resumed")
			else
				pause_playback()
				status_label:SetDesc("‚è∏Ô∏è Paused")
			end
		end
	})
	MainTab:Button({
		Title = "Stop",
		Callback = function()
			stop_playback()
			status_label:SetDesc("‚èπÔ∏è Stopped")
		end
	})
	local last_played_change = 0
	local was_playing_before_played = false
	played_slider_ref = MainTab:Slider({
		Title = "Played Time (s)",
		Step = 0.01,
		Value = {
			Min = 0,
			Max = 1,
			Default = 0
		},
		Callback = function(v)
			if ignore_played_slider_callback then
				return
			end
			if not midi_loaded or total_duration == 0 then
				return
			end
			if not paused and not was_playing_before_played then
				was_playing_before_played = true
				pause_playback()
			end
			last_played_change = os.clock()
			local sec = v
			if total_duration > 0 then
				local ratio = _math.clamp(sec / total_duration, 0, 1)
				seek_to_position(ratio)
				status_label:SetDesc("‚è© Seek: " .. string.format("%.3f", sec) .. "s / " .. string.format("%.3f", total_duration) .. "s")
			end
			_task.spawn(function()
				_task.wait(0.28)
				if os.clock() - last_played_change >= 0.28 then
					if was_playing_before_played then
						resume_playback()
						was_playing_before_played = false
					end
				end
			end)
		end
	})
	local last_speed_change = 0
	local was_playing_before_speed = false
	local speed_slider_ref
	speed_slider_ref = MainTab:Slider({
		Title = "Playback Speed (%)",
		Step = 0.1,
		Value = {
			Min = 50,
			Max = 200,
			Default = _math.floor(playback_speed * 100)
		},
		Callback = function(v)
			if ignore_speed_slider_callback then
				return
			end
			if not paused and not was_playing_before_speed then
				was_playing_before_speed = true
				pause_playback()
			end
			last_speed_change = os.clock()
			local oldpos = get_current_playback_position()
			playback_speed = _math.clamp(v / 100, 0.5, 2.0)
			pause_position = oldpos
			_task.spawn(function()
				_task.wait(0.28)
				if os.clock() - last_speed_change >= 0.28 then
					if was_playing_before_speed then
						resume_playback()
						was_playing_before_speed = false
					end
				end
			end)
		end
	})
	SettingsTab:Toggle({
		Title = "DeBlack",
		Desc = "If the MIDI file is large, use this",
		Value = deblack_enabled,
		Callback = function(v)
			deblack_enabled = v
			WindUI:Notify({
				Title = "MidiPlayer",
				Content = (deblack_enabled and "üîß Deblack ON" or "üîß Deblack OFF"),
				Duration = 3,
				Icon = "bird",
			})
		end
	})
	SettingsTab:Slider({
		Title = "DeBlack Level",
		Step = 1,
		Value = {
			Min = 0,
			Max = 127,
			Default = deblack_level
		},
		Callback = function(v)
			deblack_level = _math.clamp(_math.floor(v), 0, 127)
		end
	})
	SettingsTab:Toggle({
		Title = "Auto Sustain",
		Value = auto_sustain_enabled,
		Callback = function(v)
			auto_sustain_enabled = v
			if not auto_sustain_enabled then
				sustain = true
				_pcall(function()
					if PianoController then
						PianoController:ToggleSustain(true)
					end
				end)
			end
			WindUI:Notify({
				Title = "MidiPlayer",
				Content = (auto_sustain_enabled and "üîß AutoSustain ON" or "üîß AutoSustain OFF"),
				Duration = 3,
				Icon = "bird",
			})
		end
	})
	SettingsTab:Toggle({
		Title = "Auto Velocity",
		Value = auto_velocity_enabled,
		Callback = function(v)
			auto_velocity_enabled = v
			WindUI:Notify({
				Title = "MidiPlayer",
				Content = (auto_velocity_enabled and "üîß AutoVelocity ON" or "üîß AutoVelocity OFF"),
				Duration = 3,
				Icon = "bird",
			})
		end
	})
	SettingsTab:Toggle({
		Title = "88 Key",
		Value = key88_enabled,
		Callback = function(v)
			key88_enabled = v
			WindUI:Notify({
				Title = "MidiPlayer",
				Content = (key88_enabled and "üîß 88 Key ON" or "üîß 88 Key OFF"),
				Duration = 3,
				Icon = "bird",
			})
		end
	})
	SettingsTab:Toggle({
		Title = "Fast Note-Off",
		Value = FastNoteOff,
		Callback = function(v)
			FastNoteOff = v
			if v then
				release_all_keys()
			end
			WindUI:Notify({
				Title = "MidiPlayer",
				Content = (FastNoteOff and "üîß Fast NoteOff ON" or "üîß Fast NoteOff OFF"),
				Duration = 3,
				Icon = "bird",
			})
		end
	})
	SettingsTab:Slider({
		Title = "Fast Note-Off Delay (s)",
		Step = 0.001,
		Value = {
			Min = 0,
			Max = 2,
			Default = FastNoteOffDelay
		},
		Callback = function(v)
			FastNoteOffDelay = v
		end
	})
	SettingsTab:Toggle({
		Title = "Force Note-Off",
		Value = no_note_off_enabled,
		Callback = function(v)
			no_note_off_enabled = v
			if v then
				release_all_keys()
			end
			WindUI:Notify({
				Title = "MidiPlayer",
				Content = (no_note_off_enabled and "üîß Force NoteOff ON" or "üîß NoteOff OFF"),
				Duration = 3,
				Icon = "bird",
			})
		end
	})
	SettingsTab:Toggle({
		Title = "Loop Mode",
		Value = loop_enabled,
		Callback = function(v)
			loop_enabled = v
			WindUI:Notify({
				Title = "MidiPlayer",
				Content = (loop_enabled and "üîÅ Loop Mode ON" or "üîÅ Loop Mode OFF"),
				Duration = 3,
				Icon = "bird",
			})
		end
	})
	SettingsTab:Toggle({
		Title = "Human Player",
		Value = random_note_enabled,
		Callback = function(v)
			random_note_enabled = v
			WindUI:Notify({
				Title = "MidiPlayer",
				Content = (random_note_enabled and "üîß Human Player ON" or "üîß Human Player OFF"),
				Duration = 3,
				Icon = "bird",
			})
		end
	})
	run_service.RenderStepped:Connect(function()
		play_realtime_events()
		if midi_loaded and total_duration and total_duration > 0 then
			local elapsed = get_current_playback_position()
			if played_slider_ref then
				_pcall(function()
					ignore_played_slider_callback = true
					played_slider_ref:Set(tonumber(elapsed))
					ignore_played_slider_callback = false
				end)
			end
		end
		if speed_slider_ref then
			local current_speed = _math.floor(playback_speed * 100)
			_pcall(function()
				ignore_speed_slider_callback = true
				speed_slider_ref:Set(current_speed)
				ignore_speed_slider_callback = false
			end)
		end
	end)
	Window:SetToggleKey(Enum.KeyCode.RightControl)
	Window:ToggleTransparency(true)
	Window:SelectTab(1)
	status_label:SetDesc("‚úÖ Ready")
end)

run(function()
	if not getgenv().Bypassed then
		getgenv().Bypassed = true
		local ok, v_u_1 = _pcall(function()
			return require(Services.ReplicatedStorage.Packages.Knit)
		end)
		if ok and v_u_1 then
			v_u_1.OnStart():catch(warn):andThen(function()
				local v_u_3 = v_u_1.GetService("DetectionService")
				while true do
					v_u_3.WindowFocused:Fire(true)
					_task.wait(1)
				end
			end)
			WindUI:Notify({
				Title = "MidiPlayer",
				Content = "üõ°Ô∏è AntiAfk Bypassed!",
				Duration = 3,
				Icon = "bird",
			})
		end
	end
end)
